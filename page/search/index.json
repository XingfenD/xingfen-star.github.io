[{"content":"作业目标 逆向分析扫雷程序winmine.exe，并编写程序对其进行批量插旗\n更换机器指令表.exe内的显示字体\n扫雷 定位绘制雷区的代码位置 使用Ollydbg打开winmin.exe。\n在当前模块中右键-\u0026gt;查找-\u0026gt;当前模块中的名称（标签），在弹出的窗口中寻找名称为Bitblt的函数。这里可以直接右键-\u0026gt;在每个参考上设置断点，但是我的Ollydbg会报错。因此采用后续的方法。\n选中Bitblt项后，按回车键Enter，在弹出的窗口中再次按回车Enter。\n执行上述操作后弹出的窗口即为Bitblt的源码，在源码首行按F2或者右键设置断点。\n设置断点后按F9或功能按钮运行程序，程序会暂停在断点处。此时按Ctrl + F9或者功能按钮执行到返回，程序会运行到函数Bitblt调用处的下一行。\n观察上下文程序可以发现是类似于一个循环的结构，其中esi寄存器为循环变量。\n定位雷区数据地址 在这一节内需要观察不同操作下内存区域的变化。\n在Ollydbg中可以通过单击任意数据来刷新数据窗口中的内容。\n如果想要重新绘制扫雷窗口，需要最小化后恢复窗口。\n观察内存读取部分，代码中只有两句可能是对于数组的读取。分别为：\nmov al, byte ptr [ebx+esi] push dword ptr [eax*4+1005A20] 这里可以记录一下Bitblt调用处的地址1002706，然后取消所有断点重新运行程序，将游戏切换到高级模式，随机点击一个地块。这里为了便于定位雷区数据位置，我们多次开局点击地块，直到仅连锁翻开一个地块（这样对雷区数据的影响较小，数据特征更明显）。\n然后将在数据窗口中右键-\u0026gt;转到-\u0026gt;表达式或者按Ctrl + G，输入内存读取部分的常量地址1005A20跳转到该地址。观察数据窗口内该地址处的数据。\n发现并不符合雷区数据的特征（至少应该出现大量相同的两种数据）。实际上作为绘制雷区的函数，对数组下标的访问应该具有循环变量，也就是esi寄存器应该参与内存地址的计算，而这条指令并不符合。\n因此选择下面的指令来寻找雷区数据所在的内存地址。\nmov al, byte ptr [ebx+esi] 在这条指令上打断点后最小化扫雷窗口，再恢复窗口，查看ebx寄存器的值，发现是内存地址1005360，在数据窗口中跟踪该地址。\n该地址处的内存数据如下。可以大致推测，未翻开的雷区和未翻开的空白对应数据为0x0F或0x8F。\n再次重开游戏，翻开第一个地块以定位数据区域首个元素的位置，如下图所示。\n对比可知1005361为首的地址存放雷区数据。\n分析地块状态对应的内存值 非雷区地块 从上一节的最后一个图可以得知，翻开的2地块对应的内存值为0x42。推测翻开的n对应的内存值为0x4n。\n翻开相邻地块进行验证，可知推测成立，同时也得知未翻开的非雷区对应的内存值为0x0F。\n雷区地块 再次观察内存区域，在9个地块后，有一个地块的内存值为不同的0x8F，翻开该地块后再次观察内存区域变化。\n可知未翻开的雷为0x8F，翻开的雷为0x8A，踩中的雷为0xCC。\n插旗地块与存疑地块 重开游戏并刷新数据窗口。在任意0x8E和0x0F对应的地块上右键以插旗后，刷新数据窗口，观察对应数据变化。扫雷游戏中还有一种标记，在插旗的地块上再次右键可以变为问号地块，这里称为存疑地块，与本次任务并不相关，但是这里还是给出其对应的内存值。\n观察上图可知，插旗地块的0x?F被替换为0x?E，存疑地块的0x?F被替换为0x?D。\n至此，所有地块状态对应的内存值均被我们分析出来。\n简单总结一下，地块状态对应的内存值如下：\n地块状态 内存值 地块状态 内存值 未翻开的空地 0x0F 插旗的空地 0x0E 翻开的空地 0x4n(n为要显示的数字) 存疑的空地 0x0D 未翻开的地雷 0x8F 插旗的地雷 0x8E 翻开的地雷 0x8A 存疑的地雷 0x8D 踩中的地雷 0xCC 此外，按Ctrl + ↓调整数据窗口首列数据从0x01偏移开始展示，可以发现在高级模式下30 * 16的布局下，每30个地块的数据后都有两个0x10，用于标注此行结束，在后面编写程序时，应当注意处理这个间隔区域。\n编写程序以批量插旗地雷 程序如下：\n#include \u0026lt;windows.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;tchar.h\u0026gt; #include \u0026lt;tlhelp32.h\u0026gt; #define GET_OFFSET(ROW, COL) ((ROW) * 32 + (COL)) void print_sign(BYTE val) { if (val == 0x0F || val == 0x8F) { printf(\u0026#34;--\u0026#34;); } else if (val == 0x0E || val == 0x8E) { printf(\u0026#34;||\u0026#34;); } else if (val == 0x0D || val == 0x8D) { printf(\u0026#34;??\u0026#34;); } else if (val == 0x40) { printf(\u0026#34;..\u0026#34;); } else if (val == 0x8A) { printf(\u0026#34;**\u0026#34;); } else if (val == 0xCC) { printf(\u0026#34;XX\u0026#34;); } else if (val == 0x10) { } else { printf(\u0026#34;%01X\u0026#34;, val \u0026amp; 0x0F); printf(\u0026#34;%01X\u0026#34;, val \u0026amp; 0x0F); } printf(\u0026#34; \u0026#34;); } int main() { DWORD pid = 0; // Target process ID HANDLE hProcess = NULL; LPVOID targetAddress = (LPVOID)0x1005361; // Target memory address BYTE readBuffer[512] = {0}; // BYTE writeData[4] = {0xAA, 0xBB, 0xCC, 0xDD}; // Example data to write SIZE_T bytesRead = 0; // SIZE_T bytesWritten = 0; // Create a snapshot of all processes HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); if (hSnapshot == INVALID_HANDLE_VALUE) { printf(\u0026#34;Failed to create process snapshot, error code: %d\\n\u0026#34;, GetLastError()); return 1; } PROCESSENTRY32 pe = {sizeof(PROCESSENTRY32)}; if (Process32First(hSnapshot, \u0026amp;pe)) { do { if (_tcsicmp(pe.szExeFile, _T(\u0026#34;winmine.exe\u0026#34;)) == 0) { pid = pe.th32ProcessID; printf(\u0026#34;Process found: winmine.exe, PID: %u\\n\u0026#34;, pid); break; } } while (Process32Next(hSnapshot, \u0026amp;pe)); } else { printf(\u0026#34;Failed to retrieve process information, error code: %d\\n\u0026#34;, GetLastError()); } CloseHandle(hSnapshot); if (pid == 0) { printf(\u0026#34;Process winmine.exe not found\\n\u0026#34;); return 1; } // Open the target process with required permissions for memory operations hProcess = OpenProcess( PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_VM_OPERATION, FALSE, pid ); if (hProcess == NULL) { printf(\u0026#34;Failed to open process, error code: %d\\n\u0026#34;, GetLastError()); return 1; } // Read memory content if (!ReadProcessMemory( hProcess, targetAddress, readBuffer, sizeof(readBuffer), \u0026amp;bytesRead )) { printf(\u0026#34;Failed to read memory, error code: %d\\n\u0026#34;, GetLastError()); CloseHandle(hProcess); return 1; } printf(\u0026#34;Read %d bytes of data:\\n\u0026#34;, bytesRead); for (int i = 0; i \u0026lt; 16; i++) { for (int j = 0; j \u0026lt; 32; j++) { print_sign(readBuffer[GET_OFFSET(i, j)]); } printf(\u0026#34;\\n\u0026#34;); } printf(\u0026#34;Start flaging all the mines..\\n\u0026#34;); // Write to memory int count = 0; for (int i = 0; i \u0026lt; 16; i++) { for (int j = 0; j \u0026lt; 32; j++) { BYTE flag_mine = 0x8E; if (readBuffer[GET_OFFSET(i, j)] == 0x8F) { WriteProcessMemory( hProcess, targetAddress + GET_OFFSET(i, j), \u0026amp;flag_mine, sizeof(flag_mine), NULL ); count++; } } } printf(\u0026#34;Finish! the count of mines: %d\\n\u0026#34;, count); CloseHandle(hProcess); // system(\u0026#34;pause\u0026#34;); return 0; } 这段程序将会在打印雷区当前状态后，将所有0x8F修改为0x8E，即将所有的未翻开的地雷插上旗子，用户应当在新一局游戏内翻开任意地块后运行此程序，然后最小化再恢复窗口以重新绘制雷区。\n打印当前状态过程中，未翻开的所有地块将记为--，插旗地块记为||，翻开的空地记为..，翻开的数字地块记为该数字，翻开的地雷记为**，踩中的地雷记为XX。\n实验结果 运行结果如下图所示：\n刷新窗口后成功插旗。\n降低雷数为20后重新运行，便于验证结果正确性，手动翻开所有未插旗地块，中间笑脸图标带上墨镜（表示游戏胜利），可见结果正确。\n更换机器指令表.exe显示字体 定位控制字体显示的WinAPI 使用Ollydbg打开机器指令表.exe。\n在API文档及网络资料中查询其内涉及的API。\nAPI名称 功能 GetModuleHandle 检索指定模块的模块句柄。模块必须已由调用进程加载。 GetCommandLine 检索当前进程的命令行字符串。 ExitProcess 结束调用进程及其所有线程。 GetSystemMetrics 用于获取关于显示器、鼠标、键盘等系统参数的信息。 观察发现在程序有效的程序段中涉及的三个WinAPI均与字体显示无关。还剩下一个call 004031，推测其很可能控制字体的显示。其上的四个push可能包含参数，尝试修改为push 0D 观察程序变化。修改两个push后运行程序并无明显变化。可见这两个参数并不控制该程序的字体显示。\n在call 00401031处设断点并单步步入，依次检索遇见的到的WinAPI功能。\nAPI名称 功能 CreateWindowEx 用于创建一个窗口（包括各种控件如按钮、文本框等）。 SetWindowLong 更改指定窗口的属性。该函数还将指定偏移量处的32位(长)值设置为额外的窗口内存。 GetStockObject 用于获取预定义的图形对象（如画笔、画刷和字体）的句柄。 其中GetStockObject涉及字体的显示，在4010C6处调用，其上一条指令push 0B很可能控制字体的显示。\n将push 0B修改为push 0E后继续运行程序，可见字体明显发生变化。\n将修改保存到文件 选中被修改的指令，在指令窗口中右键-\u0026gt;复制到可执行文件-\u0026gt;选择，在弹出的新窗口中选中被修改的指令，右键-\u0026gt;保存文件。将新可执行文件命名为机器指令表2.exe。\n双击运行修改前后的机器指令表，对比两者的字体差异。\n","date":"2025-02-19T17:43:52+08:00","permalink":"https://xingfend.github.io/xingfen-star.github.io/post/reverse-program-course-week1/","title":"【武大软件逆向课程/第一周】扫雷逆向分析批量插旗及机器指令表.exe文件字体更换"},{"content":"计划 添加widget，展示当前博文的tags 右侧边栏的tag-cloud和categories不能处理hidden博文 tag-cloud识别hidden博文 把layouts/partials/widget/tag-cloud.html的渲染tag-cloud的逻辑进行如下修改：\n\u0026lt;div class=\u0026#34;tagCloud-tags\u0026#34;\u0026gt; - {{ range first $limit $context.Site.Taxonomies.tags.ByCount }} - \u0026lt;a href=\u0026#34;{{ .Page.RelPermalink }}\u0026#34; class=\u0026#34;font_size_{{ .Count }}\u0026#34;\u0026gt; - {{ .Page.Title }} - \u0026lt;/a\u0026gt; + {{- $cateTaxonomy := $context.Site.GetPage \u0026#34;tags\u0026#34; -}} + {{- $cateTerms := $cateTaxonomy.Pages -}} + {{ range first $limit $cateTerms }} + {{- $pages := .Pages -}} + {{- $filteredPages := where $pages \u0026#34;.Params.hidden\u0026#34; \u0026#34;!=\u0026#34; true -}} + {{ if $filteredPages }} + \u0026lt;a href=\u0026#34;{{ .RelPermalink }}\u0026#34; class=\u0026#34;font_size_{{ len $filteredPages}}\u0026#34;\u0026gt; + {{ .Title }} + \u0026lt;/a\u0026gt; + {{ end }} + {{ end }} \u0026lt;/div\u0026gt; 如另一篇博文中的方法，从$context.Site中获取所有tags然后过滤掉hidden == true的博文后，判断$filteredPages中是否还有元素，如果有则渲染这个tag。\n添加一种展示当前博文tags的Widget 添加模板文件 在layouts/partials/widget文件夹下新建文件cur-tags.html，添加如下内容：\n{{- $context := .Context -}} {{ if .Context.Page.Params.Tags }} \u0026lt;section class=\u0026#34;widget curTags\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;widget-icon\u0026#34;\u0026gt; {{ partial \u0026#34;helper/icon\u0026#34; \u0026#34;tag\u0026#34; }} \u0026lt;/div\u0026gt; \u0026lt;h2 class=\u0026#34;widget-title section-title\u0026#34;\u0026gt;{{ T \u0026#34;widget.curTags.title\u0026#34; }}\u0026lt;/h2\u0026gt; \u0026lt;div class=\u0026#34;curTags-tags\u0026#34;\u0026gt; {{ range (.Context.Page.GetTerms \u0026#34;tags\u0026#34;) }} \u0026lt;a href=\u0026#34;{{ .RelPermalink }}\u0026#34;\u0026gt; {{ .LinkTitle }} \u0026lt;/a\u0026gt; {{ end }} \u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; {{ end }} 首先判断当前文章是否有tag，然后根据其他widget的模板修改成current tags，使用GetTerms方法获得当前文章的tags，作为\u0026lt;a\u0026gt;标签的参数。\n注意\u0026lt;h2\u0026gt;标签中的T函数，用于在修改页面语言时批量替换文本，我们需要在对应文件中添加widget.curTags.title命名空间的值。\n添加i18n替换文本 在i18n/en.yaml和i18n/zh-cn.yaml中添加相关内容，在widget域下添加内容：\nwidget: + curTags: + title: + other: Tags of current blog 添加scss样式表 在assets/scss/partials/widgets.scss中添加curTags的样式。\n/* Current tags widget */ .curTags { .curTags-tags { display: flex; flex-wrap: wrap; gap: 10px; a { background: var(--card-background); box-shadow: var(--shadow-l1); border-radius: var(--tag-border-radius); padding: 8px 20px; color: var(--card-text-color-main); font-size: 1.4rem; transition: box-shadow 0.3s ease; \u0026amp;:hover { box-shadow: var(--shadow-l2); } } } } 自此，current tags控件的开发已经成功，在stack/config.yaml中添加配置项即可。\nparams: widgets: page: + - type: cur-tags ","date":"2025-02-12T16:33:24+08:00","image":"https://xingfend.github.io/xingfen-star.github.io/post/blogbuild2-widgets/blogbuild2_hu_e35aa4add03418f0.png","permalink":"https://xingfend.github.io/xingfen-star.github.io/post/blogbuild2-widgets/","title":"Widgets修复与开发"},{"content":"Archive页介绍 archive页面展示了当前博文的所有类型，在此之下依据年份时序展示所有博文。\n改造计划:\n添加对以tag分类的支持\n支持在archive页展示tag模块\n修改tag\u0026ndash;tile的大小\n修改tag\u0026ndash;tile的排列方式\n为tag分类的每一个tile添加不同颜色\n修复在archive页面的category tile展示异常\n修复category详细页的文章数量异常\n添加archive页面对应配置项\n使用开发者工具检查archive页面元素 发现category分类的元素为：\n\u0026lt;h2 class=\u0026#34;section-title\u0026#34;\u0026gt;类别 - Categories\u0026lt;/h2\u0026gt; \u0026lt;div class=\u0026#34;subsection-list\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;article-list--tile\u0026#34;\u0026gt; \u0026lt;article\u0026gt; \u0026lt;/article\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 显然\u0026lt;div class=\u0026quot;article-list--tile\u0026quot;\u0026gt;的class属性命名并不合理，因为在archive首页展示的category列表的每一个tile并不是一篇article，因此应当修改为\u0026lt;div class=\u0026quot;category-list--tile\u0026quot;\u0026gt;。\n在文件themes/hugo-theme-stack/layouts/_default/archives.html中将\u0026lt;div class=\u0026quot;article-list--tile\u0026quot;\u0026gt;修改为\u0026lt;div class=\u0026quot;category-list--tile\u0026quot;\u0026gt;。\n同时将下列文件中的选择器article-list--tile修改为category-list--tile。在scss文件中建议保留原有的选择器，新增修改名称后的选择器。\nthemes/hugo-theme-stack/assets/scss/partials/article.scss themes/hugo-theme-stack/assets/scss/partials/layout/list.scss /home/fendy/Project/BlogSrc/themes/hugo-theme-stack/assets/ts/main.ts 修复category tile展示异常 本质上是没有添加对hidden文章的判断逻辑，在themes/hugo-theme-stack/layouts/_default/archives.html中添加筛选逻辑：\n\u0026lt;h2 class=\u0026#34;section-title\u0026#34;\u0026gt;类别 - {{ $cateTaxonomy.Title }}\u0026lt;/h2\u0026gt; \u0026lt;div class=\u0026#34;subsection-list\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;category-list--tile\u0026#34;\u0026gt; {{ range $cateTerms }} {{- $pages := .Pages -}} {{- $filteredPages := where $pages \u0026#34;.Params.hidden\u0026#34; \u0026#34;!=\u0026#34; true -}} {{ if $filteredPages }} {{ partial \u0026#34;article-list/tile\u0026#34; (dict \u0026#34;context\u0026#34; . \u0026#34;size\u0026#34; \u0026#34;250x150\u0026#34; \u0026#34;Type\u0026#34; \u0026#34;taxonomy\u0026#34;) }} {{ end }} {{ end }} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 添加对tag分类的支持 支持在archive页展示tag模块 在themes/hugo-theme-stack/layouts/_default/archives.html中，类别模块的下方添加如下代码：\n{{- $tagTaxonomy := $.Site.GetPage \u0026#34;taxonomyTerm\u0026#34; \u0026#34;tags\u0026#34; -}} {{- $tagTerms := $tagTaxonomy.Pages -}} {{ if $tagTerms }} \u0026lt;h2 class=\u0026#34;section-title\u0026#34;\u0026gt;标签 - {{ $tagTaxonomy.Title }}\u0026lt;/h2\u0026gt; \u0026lt;div class=\u0026#34;subsection-list\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;tag-list--tile\u0026#34;\u0026gt; {{ range $tagTerms }} {{/* 获取当前标签下的所有页面 */}} {{- $pages := .Pages -}} {{/* 过滤掉 hidden 为 true 的页面 */}} {{- $filteredPages := where $pages \u0026#34;.Params.hidden\u0026#34; \u0026#34;!=\u0026#34; true -}} {{ if $filteredPages }} {{ partial \u0026#34;article-list/tile\u0026#34; (dict \u0026#34;context\u0026#34; . \u0026#34;Type\u0026#34; \u0026#34;tag\u0026#34; \u0026#34;pages\u0026#34; $filteredPages) }} {{ end }} {{ end }} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; {{ end }} 添加tag的样式并修改tag\u0026ndash;tile的大小 在themes/hugo-theme-stack/assets/scss/partials/article.scss中添加:\n.tag-list--tile { article { border-radius: var(--card-border-radius); overflow: hidden; position: relative; height: 350px; width: 250px; box-shadow: var(--shadow-l1); transition: box-shadow 0.3s ease; background-color: var(--card-background); \u0026amp;:hover { box-shadow: var(--shadow-l2); } .article-details { border-radius: var(--card-border-radius); position: relative; height: 100%; width: 100%; display: flex; flex-direction: column; justify-content: flex-end; z-index: 2; padding: 15px; @include respond(sm) { padding: 20px; } } .article-title { font-size: 2rem; font-weight: 500; color: var(--card-text-color-main); @include respond(sm) { font-size: 2.2rem; } } } } 在themes/hugo-theme-stack/assets/scss/partials/layout/list.scss中添加:\n.tag-list--tile { display: flex; article { width: 120px; height: 30px; margin-right: 20px; flex-shrink: 0; .article-title { margin: 0; font-size: 1.8rem; } .article-details { padding-bottom: 5px; text-align: center; } } } 添加archives页面对应配置项 设计配置项 由于目前archives页面有三个板块：Categories，Tags，Dates。考虑添加如下配置项（标注出的为默认配置，不进行配置也会以下面代码块给定的配置渲染）：\nparams: archives: showCategories: true showTags: false showDates: true 修改对应源码读取配置项 修改layouts/_default/archives.html文件，将{{ if $term }}判断语句添加一个与项，同时修改变量名。最终修改后结果如下：\n{{ if and (eq (.Site.Params.archives.showCategories | default true) true) (gt (len $cateTerms) 0) }} 同理，在渲染tags和dates板块的部分使用如下语句对包裹：\n{{ if and (eq (.Site.Params.archives.showTags | default false) true) (gt (len $tagTerms) 0) }} {{ /* 渲染Tags板块 */ }} {{ end }} {{ if eq (.Site.Params.archives.showDates | default true) true }} {{ /* 渲染Dates板块*/ }} {{ end }} 修复category详细页的文章数量异常问题 在layouts/_default/list.html文件中进行如下修改：\n- \u0026lt;h3 class=\u0026#34;section-count\u0026#34;\u0026gt;{{ T \u0026#34;list.page\u0026#34; (len .Pages) }}\u0026lt;/h3\u0026gt; + {{- $filteredPages := where .Pages \u0026#34;.Params.hidden\u0026#34; \u0026#34;!=\u0026#34; true -}} + \u0026lt;h3 class=\u0026#34;section-count\u0026#34;\u0026gt;{{ T \u0026#34;list.page\u0026#34; (len $filteredPages) }}\u0026lt;/h3\u0026gt; 把.Pages的元素个数替换为筛选后的元素个数。\n新增分类方式：collections 设计配置项 在layouts/_default/archives.html中添加配置项showCollections。\nparams: archives: showCategories: true + showCollections: true showTags: false showDates: true 修改archive.html渲染collections列表 \u0026lt;!-- Collections Section --\u0026gt; {{- $collectionTaxonomy := $.Site.GetPage \u0026#34;collections\u0026#34; -}} {{- $collectionTerms := $collectionTaxonomy.Pages -}} {{ if and (eq (.Site.Params.archives.showCollections | default false) true) (gt (len $collectionTerms) 0) }} \u0026lt;h2 class=\u0026#34;section-title\u0026#34;\u0026gt;合集 - {{ $collectionTaxonomy.Title }}\u0026lt;/h2\u0026gt; \u0026lt;div class=\u0026#34;subsection-list\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;category-list--tile\u0026#34;\u0026gt; {{ range $collectionTerms }} {{- $pages := .Pages -}} {{- $filteredPages := where $pages \u0026#34;.Params.hidden\u0026#34; \u0026#34;!=\u0026#34; true -}} {{ if $filteredPages }} {{ partial \u0026#34;article-list/tile\u0026#34; (dict \u0026#34;context\u0026#34; . \u0026#34;size\u0026#34; \u0026#34;250x150\u0026#34; \u0026#34;Type\u0026#34; \u0026#34;taxonomy\u0026#34;) }} {{ end }} {{ end }} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; {{ end }} 在文件layouts/_default/archives.html中需要的位置添加如上代码。这篇博客是在categories和tags中间添加。\n修改配置文件 修改hugo.toml添加如下配置项。\n[taxonomies] category = \u0026#39;categories\u0026#39; tag = \u0026#39;tags\u0026#39; collection = \u0026#39;collections\u0026#39; 新建模板文件 在content文件夹下新建文件夹collections，在collections文件夹下如category一般新建分类项。如新建子目录及文件test-collection/_index.md，并在子目录中添加如下内容：\n--- title: \u0026#34;测试用\u0026#34; description: \u0026#34;test\u0026#34; --- 在这之后就可以在博文的front-matter中添加如下内容，以将这篇博文归类到一个合集中：\ncollections = \u0026#34;test-collection\u0026#34; 效果展示 新建合集rvs-enr-crs选择一篇博文添加collections = \u0026quot;rvs-env-crs\u0026quot;。\n可见成功生效。\n","date":"2025-02-02T22:46:55+08:00","image":"https://xingfend.github.io/xingfen-star.github.io/post/blogbuild1-archive/blogbuild1_hu_538f0d4bb236f725.png","permalink":"https://xingfend.github.io/xingfen-star.github.io/post/blogbuild1-archive/","title":"Archive页改造"},{"content":" 此博客搭建过程参考的资料在\u0026quot;关于\u0026quot;页面可详细了解。本文具体步骤也可能会给出具体参考的内容。\n不能正确渲染主题 - 2025.01.28 此博客采用源码-博客页分离的结构搭建。\n源码为hugo个人博客的源码，设为github私有仓库，通过git action，在每次push之后，通过hugo -D命令云端编译生成public文件夹中的内容之后将public文件夹内的内容推送到GitHub - XingfenD/xingfen-star.github.io仓库中。\n在搭建阶段，我将themes子文件夹下的第三方主题仓库设置为该主项目的子模块，导致在上传到私有仓库后，themes文件夹中没有实际的主题文件。最终导致无法编译出所选主题的页面。\n我在github action中添加步骤Print Directory以打印路径信息，最终定位此问题并修复，完整的githu action如下。\n最终博客项目的结构为三个仓库：\nHugo源码仓库(通过gitignore忽略public, resources, themes文件夹)\n主题仓库(Hugo源码仓库的public文件夹)\nGithub Page仓库(Hugo源码仓库的public文件夹)\nname: deploy # 代码提交到main分支时触发github action on: push: branches: - main jobs: deploy: runs-on: ubuntu-22.04 steps: - name: Checkout uses: actions/checkout@v4 with: fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v3 with: hugo-version: \u0026#34;latest\u0026#34; extended: true - name: Print Directory run: tree -L 3 -d - name: Clone Theme run: git clone https://github.com/XingfenD/hugo-theme-custom.git themes - name: Git Configuration run: | git config --global core.quotePath false git config --global core.autocrlf false git config --global core.safecrlf true git config --global core.ignorecase false - name: Build Web run: hugo -D - name: Print Directory run: tree -L 3 -d - name: Deploy Web uses: peaceiris/actions-gh-pages@v4 with: personal_token: ${{ secrets.ACTION_ACCESS_TOKEN }} external_repository: XingfenD/xingfen-star.github.io publish_branch: main publish_dir: public commit_message: auto deploy 主题配置后代码块显示异常 - 2025.02.02 使用hugo-theme-stack主题后\n发现在白天模式下的代码块颜色异常，如下图所示：\n在通过修改hugo-theme-stack主题的scss文件后成功定位异常原因：\nhugo编译md文件后生成的博文html文件中的codeblock为如下结构: \u0026lt;div class=\u0026#34;highlight\u0026#34;\u0026gt; \u0026lt;pre style=\u0026#34;\u0026#34;\u0026gt; \u0026lt;code class=\u0026#34;language-markdown\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34;\u0026gt; ... \u0026lt;/code\u0026gt; \u0026lt;/pre\u0026gt; \u0026lt;/div\u0026gt; 图中所示的深色异常颜色为\u0026lt;pre\u0026gt;标签的style属性控制，因此导致全局scss文件失效。\n阅读官方文档后，在`hugo.toml`中添加配置： markup.highlight.noClasses=false 问题得以修复。\n修改配置文件以激活右侧边栏 - 2025.02.12 阅读Stack主题官方文档右侧边栏配置项可以了解如何修改配置文件以激活右边栏。\n在config.yaml文件中修改配置项[params.widgets]:\nparams: widgets: homepage: - type: search - type: categories params: limit: 10 - type: tag-cloud params: limit: 10 page: - type: toc - type: categories params: limit: 5 - type: tag-cloud params: limit: 5 配置生效后右侧边栏效果如下图:\n不能正确渲染abbr, sub等特殊html标签 - 2025.02.12 查阅在线资料修复Hugo静态生成器中忽略原始HTML的方法后，在hugo.toml中添加配置项：\nmarkup.goldmark.renderer.unsafe=true 成功渲染，效果如图。\n","date":"2025-02-02T17:21:58+08:00","image":"https://xingfend.github.io/xingfen-star.github.io/post/hugo-githubio/facebook_cover_photo_2_hu_43e45dd37002c568.png","permalink":"https://xingfend.github.io/xingfen-star.github.io/post/hugo-githubio/","title":"hugo+GithubIO自建博客踩坑实录"},{"content":"本文提供了可以在 Hugo 内容文件中使用的最基本 Markdown 语法样本，同时也展示了基本 HTML 元素是否可以通过 Hugo 主题中的 CSS 被装饰。\n标题 以下 HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; 元素代表六个级别的章节标题。\u0026lt;h1\u0026gt; 是最高级别，而 \u0026lt;h6\u0026gt; 是最低级别。\n# H1 ## H2 ### H3 #### H4 ##### H5 ###### H6 H1 H2 H3 H4 H5 H6 段落 Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\n引用块 引用块元素表示来自另一个源的内容，并且可选地带有必须在 footer 或 cite 元素内的引用，以及可选的如注释和缩写的行内更改。\n无属性的引用块 Tiam, ad mint andaepu dandae nostion secatur sequo quae. 注意 在引用块中可以使用 Markdown 语法。\n带有属性的引用块 \u0026gt; 不要通过共享内存来通信，而是通过通信来共享内存。\u0026lt;br\u0026gt; \u0026gt; — \u0026lt;cite\u0026gt;Rob Pike[^1]\u0026lt;/cite\u0026gt; [^1]: 上述引用摘自 Rob Pike 在 Gopherfest 2015 年 11 月 18 日[演讲](https://www.youtube.com/watch?v=PAAkCSZUG1c)的部分内容。 不要通过共享内存来通信，而是通过通信来共享内存。\n— Rob Pike1\n表格 表格不属于核心 Markdown 规范的一部分，但 Hugo 开箱即用地支持它们。\n名称 年龄 Bob 27 Alice 23 表格中的内联 Markdown 斜体 粗体 代码 斜体 粗体 代码 A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien 代码块 使用反引号的代码块 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;示例 HTML5 文档\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;测试\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 使用四个空格缩进的代码块 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;示例 HTML5 文档\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;测试\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;示例 HTML5 文档\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;测试\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 使用 Hugo 的内部 highlight 短代码的代码块 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;示例 HTML5 文档\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;测试\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff 代码块 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] 列表类型 有序列表 第一项 第二项 第三项 无序列表 列表项 另一个项目 再一个项目 嵌套列表 水果 苹果 橙子 香蕉 奶制品 牛奶 奶酪 其他元素——abbr, sub, sup, kbd, mark \u0026lt;abbr title=\u0026#34;图形交换格式\u0026#34;\u0026gt;GIF\u0026lt;/abbr\u0026gt; 是一种位图图像格式。 H\u0026lt;sub\u0026gt;2\u0026lt;/sub\u0026gt;O X\u0026lt;sup\u0026gt;n\u0026lt;/sup\u0026gt; + Y\u0026lt;sup\u0026gt;n\u0026lt;/sup\u0026gt; = Z\u0026lt;sup\u0026gt;n\u0026lt;/sup\u0026gt; 按下 \u0026lt;kbd\u0026gt;CTRL\u0026lt;/kbd\u0026gt; + \u0026lt;kbd\u0026gt;ALT\u0026lt;/kbd\u0026gt; + \u0026lt;kbd\u0026gt;Delete\u0026lt;/kbd\u0026gt; 结束会话。 大多数 \u0026lt;mark\u0026gt;蝾螈\u0026lt;/mark\u0026gt; 是夜行性的，并猎食昆虫、蠕虫和其他小生物。 GIF 是一种位图图像格式。\nH2O\nXn + Yn = Zn\n按下 CTRL + ALT + Delete 结束会话。\n大多数 蝾螈 是夜行性的，并猎食昆虫、蠕虫和其他小生物。\n超链接图片 上述引用摘自 Rob Pike 在 Gopherfest 2015 年 11 月 18 日演讲的部分内容。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2025-02-02T00:00:00Z","image":"https://xingfend.github.io/xingfen-star.github.io/post/markdown-syntax/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu_e95a4276bf860a84.jpg","permalink":"https://xingfend.github.io/xingfen-star.github.io/post/markdown-syntax/","title":"Markdown 语法指南"},{"content":"getopt.h简介 getopt.h 是C语言中一个用于处理命令行参数的内嵌库。可以通过以下两个函数来调用其功能：\ngetopt()\ngetopt_long()\n函数 getopt() getopt() 用于解析仅包含短选项的指令，例如 -g、-o、-f。\ngetopt() 示例程序 使用 getopt() 的参数处理框架如下：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;getopt.h\u0026gt; int main(int argc, char *argv[]) { int opt; /* parse the command line input */ while ((opt = getopt(argc, argv, \u0026#34;f:o:kh\u0026#34;)) != -1) { switch (opt) { case \u0026#39;f\u0026#39;: printf(\u0026#34;Arg -f: %s\\n\u0026#34;, optarg); break; case \u0026#39;o\u0026#39;: printf(\u0026#34;Arg -o: %s\\n\u0026#34;, optarg); break; case \u0026#39;k\u0026#39;: printf(\u0026#34;Arg -k do not need arguments:%s\\n\u0026#34;, optarg); break; case \u0026#39;h\u0026#39;: printf(\u0026#34;Arg -k do not need arguments:%s\\n\u0026#34;, optarg); break; case \u0026#39;?\u0026#39;: // An invalid option was found or a required argument is missing. if (optopt == \u0026#39;f\u0026#39; || optopt == \u0026#39;o\u0026#39;) { printf(\u0026#34;Option -%c requires an argument.\\n\u0026#34;, optopt); } else { printf(\u0026#34;Unknown option -%c.\\n\u0026#34;, optopt); } break; default: printf(\u0026#34;Unexpected situation.\\n\u0026#34;); break; } } /* extra arguments handling */ if (optind \u0026lt; argc) { printf(\u0026#34;Remaining arguments: \u0026#34;); for (; optind \u0026lt; argc; optind++) { printf(\u0026#34;%s \u0026#34;, argv[optind]); } } /* optind \u0026lt; argc */ } 编译并运行如下指令：./test_short.out -v yuanshen -f arg:f -o arg:o -k arg:k -h arg:h\n\u0026gt; ./test_short.out -v yuanshen -f arg:f -o arg:o -k arg:k -h arg:h ./test_short.out: invalid option -- \u0026#39;v\u0026#39; Invalid option: v Arg -f: arg:f Arg -o: arg:o Arg -k do not need arguments:(null) Arg -k do not need arguments:(null) Remaining arguments: yuanshen arg:k arg:h % getopt()详细说明 全局变量 全局变量 用途 optopt (int) 遇到未知选项或缺少必要参数时设置，存储导致错误的选项字符。 optarg (char*) 存储当前选项的参数值。当解析需要参数的选项（例如 -f file.txt 中的 file.txt）时，optarg 指向该字符串。 optind (int) 在解析命令行参数过程中，追踪位置，具体指示下一个要处理的参数的索引。 以下代码段会打印所有未被 getopt() 识别的参数（忽略这些参数的输入顺序）：\n/* extra arguments handling */ if (optind \u0026lt; argc) { printf(\u0026#34;Remaining arguments: \u0026#34;); for (; optind \u0026lt; argc; optind++) { printf(\u0026#34;%s \u0026#34;, argv[optind]); } } 模式字符串 模式字符串的定义是 const char *__shortopts，在示例程序中，其实例为 \u0026quot;f:o:kh\u0026quot;。\n顾名思义，模式字符串定义了 getopt() 和 getopt_long() 函数中将被识别的短选项。冒号 : 跟在短选项字符后表示该选项需要一个参数。\n以 \u0026quot;f:o:kh\u0026quot; 为例，此模式字符串接收4个选项。选项 -f 和 -o 需要输入参数，而选项 -k 和 -h 不需要。\n注意：如果 -f 后跟一个选项，该选项会被视为参数。\n函数 getopt_long() getopt_long() 用于解析既包含短选项（如 -g、-o、-f）又包含长选项（如 --version、--input）的指令。\n函数 getopt_long 识别一个结构体数组 struct option，该数组定义了长选项的信息。\nstruct option 的原型及相关介绍如下：\nstruct option { const char *name; /* 长选项的名称 */ int has_arg; /* 是否需要参数 */ int *flag; /* 如果用户提供了此选项，*flag 将被赋值为 @val */ int val; /* 将长选项与短选项绑定，或赋值给 @*flag */ }; 字段 has_arg 有两个有效值，即宏 no_argument 和 required_argument。\n如果字段 flag 未提供，则字段 val 会被视为与当前长选项绑定的短选项。\n如果提供了字段 flag，当用户提供当前长选项时，字段 val 将被赋值给 *flag。\n用实例详细说明 以下是一个使用 struct option 数组和模式字符串的实例：\n/* the corresponding pattern string */ const char *pattern = \u0026#34;suR:\u0026#34;; struct option long_options[] = { /* long option only */ /* with flag set - 1 */ { \u0026#34;onlyset1\u0026#34;, no_argument, \u0026amp;onlyset1, 1 }, /* long option only */ /* with flag set - 2 */ { \u0026#34;onlyset2\u0026#34;, no_argument, \u0026amp;onlyset1, 2 }, /* long option only */ /* with flag set - 3 */ { \u0026#34;onlyset3\u0026#34;, no_argument, \u0026amp;onlyset2, 3 }, /* long option only ( bind failed ) */ /* with flag set, with val bind */ { \u0026#34;setbind\u0026#34;, no_argument, \u0026amp;setbind_flag, \u0026#39;s\u0026#39; }, /* short and long option */ /* without flag set, with val bind */ { \u0026#34;unsetbind\u0026#34;, no_argument, NULL, \u0026#39;u\u0026#39; }, /* short and long option */ /* require argument */ { \u0026#34;RequireArg\u0026#34;, required_argument, NULL, \u0026#39;R\u0026#39; }, }; 考虑到短选项和长选项，当提到某个功能的option时，可能会有以下三种情况：\n仅有短选项 仅有长选项 同时具有短选项和长选项 结合模式字符串和 struct option 数组，程序接收的选项如下：\n短选项 长选项 \u0026ndash;onlyset1 \u0026ndash;onlyset2 \u0026ndash;onlyset3 \u0026ndash;setbind -s -u \u0026ndash;unsetbind -R \u0026ndash;RequireArg 选项 -s 和 --setbind 并未绑定在一起，因为在与 \u0026quot;setbind\u0026quot; 对应的结构体元素中设置了字段 flag。\n参数需求冲突 当短选项和长选项中都定义了参数需求时，可能会发生冲突。\n我们通过一个实例进行说明：\n/* the corresponding pattern string */ const char *pattern = \u0026#34;c:d\u0026#34;; struct option long_options = { /* short and long option */ /* conflict argument require - 1 */ { \u0026#34;Conflict1\u0026#34;, no_argument, NULL, \u0026#39;c\u0026#39; }, /* short and long option */ /* conflict argument require - 2 */ { \u0026#34;Conflict2\u0026#34;, required_argument, NULL, \u0026#39;d\u0026#39;}, /* end of the array ( all zero ) */ { 0, 0, 0, 0 } }; 我们可以看到，上述程序将一个需要参数的短选项 -c 与一个不需要参数的长选项 --Conflict1 绑定在一起。\n同时，它还将一个不需要参数的短选项 -d 与一个需要参数的长选项 --Conflict2 绑定在一起。\n该程序运行正常，但关于参数的配置也会生效。\n当用户提供 -c 或 --Conflict1 时，程序会进入同一个分支，但 --Conflict1 不会读取后续的参数，而 -c 会读取。\n当用户提供 -d 或 --Conflict2 时，结果则相反。\ngetopt_long() 示例程序 以下是使用 getopt_long() 的参数处理框架：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;getopt.h\u0026gt; /* test instructions: ./test_long.out --onlyset1 --onlyset2 --onlyset3 ./test_long.out -s --setbind ./test_long.out --unsetbind --RequireArg arg:RequireArg ./test_long.out -u -R arg:R ./test_long.out -c arg:c -d arg:d ./test_long.out --Conflict1 arg:Conflict1 --Conflict2 arg:Conflict2 ./test_long.out -c arg:c --Conflict1 arg:Conflict1 ./test_long.out --Conflict1 arg:Conflict1 -c arg:c */ int main(int argc, char *argv[]) { int opt; int onlyset1 = 0; int onlyset2 = 0; int setbind_flag = 0; struct option long_options[] = { /* long option only */ /* with flag set - 1 */ { \u0026#34;onlyset1\u0026#34;, no_argument, \u0026amp;onlyset1, 1 }, /* long option only */ /* with flag set - 2 */ { \u0026#34;onlyset2\u0026#34;, no_argument, \u0026amp;onlyset1, 2 }, /* long option only */ /* with flag set - 3 */ { \u0026#34;onlyset3\u0026#34;, no_argument, \u0026amp;onlyset2, 3 }, /* long option only ( bind failed ) */ /* with flag set, with val bound */ { \u0026#34;setbind\u0026#34;, no_argument, \u0026amp;setbind_flag, \u0026#39;s\u0026#39; }, /* short and long option */ /* without flag set, with val bound */ { \u0026#34;unsetbind\u0026#34;, no_argument, NULL, \u0026#39;u\u0026#39; }, /* short and long option */ /* require argument */ { \u0026#34;RequireArg\u0026#34;, required_argument, NULL, \u0026#39;R\u0026#39; }, /* short and long option */ /* conflict argument require - 1 */ { \u0026#34;Conflict1\u0026#34;, no_argument, NULL, \u0026#39;c\u0026#39; }, /* short and long option */ /* conflict argument require - 2 */ { \u0026#34;Conflict2\u0026#34;, required_argument, NULL, \u0026#39;d\u0026#39;}, /* end of the array ( all zero ) */ { 0, 0, 0, 0 } }; int long_index = 0; while ((opt = getopt_long(argc, argv, \u0026#34;suR:c:d\u0026#34;, long_options, \u0026amp;long_index)) != -1) { switch (opt) { case 0: /* provide long option with flag set */ printf(\u0026#34;long option with flag set recognized!\\n\u0026#34;); printf(\u0026#34;long option name is %s\\n\u0026#34;, long_options[long_index].name); if (long_options[long_index].flag != NULL) { printf(\u0026#34;the flag value is %d\\n\u0026#34;, *(long_options[long_index].flag)); } break; case \u0026#39;s\u0026#39;: /* provide option -s instead of --setbind */ printf(\u0026#34;long option (short option only), with flag set, with val bound.\\n\u0026#34;); printf(\u0026#34;setbind_flag == %d\\n\u0026#34;, setbind_flag); break; case \u0026#39;u\u0026#39;: /* provide option -u and --unsetbind */ printf(\u0026#34;long option, without flag set, with val bound.\\n\u0026#34;); break; case \u0026#39;R\u0026#39;: /* provide option -R and --RequireArg */ printf(\u0026#34;long option require argument.\\n\u0026#34;); printf(\u0026#34;the argument: %s\\n\u0026#34;, optarg); break; case \u0026#39;c\u0026#39;: /* -c require an argument while --Conflict1 not */ printf(\u0026#34;conflict argument require - 1\\n\u0026#34;); printf(\u0026#34;the argument: %s\\n\u0026#34;, optarg); break; case \u0026#39;d\u0026#39;: /* --Conflict2 require an argument while -d not */ printf(\u0026#34;conflict argument require - 2\\n\u0026#34;); printf(\u0026#34;the argument: %s\\n\u0026#34;, optarg); break; case \u0026#39;?\u0026#39;: /* Unrecognized option or missing argument */ printf(\u0026#34;Unknown option or missing argument.\\n\u0026#34;); break; } printf(\u0026#34;\\n\u0026#34;); } /* Process remaining non-option arguments */ for (int index = optind; index \u0026lt; argc; index++) printf(\u0026#34;Non-option argument %s\\n\u0026#34;, argv[index]); return 0; } 运行测试指令并分析测试结果 编译运行时的测试指令如下：\n./test_long.out --onlyset1 --onlyset2 --onlyset3 ./test_long.out -s --setbind ./test_long.out --unsetbind --RequireArg arg:RequireArg ./test_long.out -u -R arg:R ./test_long.out -c arg:c -d arg:d ./test_long.out --Conflict1 arg:Conflict1 --Conflict2 arg:Conflict2 ./test_long.out -c arg:c --Conflict1 arg:Conflict1 ./test_long.out --Conflict1 arg:Conflict1 -c arg:c 结果如下：\n\u0026gt; ./test_long.out --onlyset1 --onlyset2 --onlyset3 long option with flag set recognized! long option name is onlyset1 the flag value is 1 long option with flag set recognized! long option name is onlyset2 the flag value is 2 long option with flag set recognized! long option name is onlyset3 the flag value is 3 指令 ./test_long.out --onlyset1 --onlyset2 --onlyset3 展示了 getopt_long() 的基本功能。\n它改变了 flag 地址中的值。\n\u0026gt; ./test_long.out -s --setbind long option (short option only), with flag set, with val bound. setbind_flag == 0 long option with flag set recognized! long option name is setbind the flag value is 115 指令 ./test_long.out -s --setbind 展示了绑定失败（当 flag 字段被设置时）。\n--setbind 和 -s 会进入不同的分支。\n\u0026gt; ./test_long.out --unsetbind --RequireArg arg:RequireArg long option, without flag set, with val bound. long option require argument. the argument: arg:RequireArg \u0026gt; ./test_long.out -u -R arg:R long option, without flag set, with val bound. long option require argument. the argument: arg:R 这对比展示了绑定成功的结果（当 flag 字段未设置时）。\n--unsetbind 和 -u 被绑定在一起，进入相同的分支。\n--RequireArg 和 -R 也是一样。\n\u0026gt; ./test_long.out -c arg:c -d arg:d conflict argument require - 1 the argument: arg:c conflict argument require - 2 the argument: (null) Non-option argument arg:d \u0026gt; ./test_long.out --Conflict1 arg:Conflict1 --Conflict2 arg:Conflict2 conflict argument require - 1 the argument: (null) conflict argument require - 2 the argument: arg:Conflict2 Non-option argument arg:Conflict1 这对比展示了参数要求的冲突。\n-c 和 --Conflict1 被绑定在一起，但 -c 需要一个参数。\n-d 和 --Conflict2 被绑定在一起，但 --Conflict2 需要一个参数。\n结果显示，绑定在一起的选项会进入相同的分支。\n但是，是否读取或忽略参数取决于用户提供的选项是否需要参数。\n\u0026gt; ./test_long.out -c arg:c --Conflict1 arg:Conflict1 conflict argument require - 1 the argument: arg:c conflict argument require - 1 the argument: (null) Non-option argument arg:Conflict1 \u0026gt; ./test_long.out --Conflict1 arg:Conflict1 -c arg:c conflict argument require - 1 the argument: (null) conflict argument require - 1 the argument: arg:c Non-option argument arg:Conflict1 冲突选项的另一个对比结果。\n","date":"2025-01-22T13:29:03+08:00","permalink":"https://xingfend.github.io/xingfen-star.github.io/post/c-getopt_h-analysis/","title":"c语言getopt.h库解析"}]