[{"content":"计划 添加widget，展示当前博文的tags 修复右侧边栏categories的tile顺序会异常变化的问题 右侧边栏的tag-cloud和categories不能处理hidden博文 tag-cloud识别hidden博文 把layouts/partials/widget/tag-cloud.html的渲染tag-cloud的逻辑进行如下修改：\n\u0026lt;div class=\u0026#34;tagCloud-tags\u0026#34;\u0026gt; - {{ range first $limit $context.Site.Taxonomies.tags.ByCount }} - \u0026lt;a href=\u0026#34;{{ .Page.RelPermalink }}\u0026#34; class=\u0026#34;font_size_{{ .Count }}\u0026#34;\u0026gt; - {{ .Page.Title }} - \u0026lt;/a\u0026gt; + {{- $cateTaxonomy := $context.Site.GetPage \u0026#34;tags\u0026#34; -}} + {{- $cateTerms := $cateTaxonomy.Pages -}} + {{ range first $limit $cateTerms }} + {{- $pages := .Pages -}} + {{- $filteredPages := where $pages \u0026#34;.Params.hidden\u0026#34; \u0026#34;!=\u0026#34; true -}} + {{ if $filteredPages }} + \u0026lt;a href=\u0026#34;{{ .RelPermalink }}\u0026#34; class=\u0026#34;font_size_{{ len $filteredPages}}\u0026#34;\u0026gt; + {{ .Title }} + \u0026lt;/a\u0026gt; + {{ end }} + {{ end }} \u0026lt;/div\u0026gt; 如另一篇博文中的方法，从$context.Site中获取所有tags然后过滤掉hidden == true的博文后，判断$filteredPages中是否还有元素，如果有则渲染这个tag。\n添加一种展示当前博文tags的Widget 添加模板文件 在layouts/partials/widget文件夹下新建文件cur-tags.html，添加如下内容：\n{{- $context := .Context -}} {{ if .Context.Page.Params.Tags }} \u0026lt;section class=\u0026#34;widget curTags\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;widget-icon\u0026#34;\u0026gt; {{ partial \u0026#34;helper/icon\u0026#34; \u0026#34;tag\u0026#34; }} \u0026lt;/div\u0026gt; \u0026lt;h2 class=\u0026#34;widget-title section-title\u0026#34;\u0026gt;{{ T \u0026#34;widget.curTags.title\u0026#34; }}\u0026lt;/h2\u0026gt; \u0026lt;div class=\u0026#34;curTags-tags\u0026#34;\u0026gt; {{ range (.Context.Page.GetTerms \u0026#34;tags\u0026#34;) }} \u0026lt;a href=\u0026#34;{{ .RelPermalink }}\u0026#34;\u0026gt; {{ .LinkTitle }} \u0026lt;/a\u0026gt; {{ end }} \u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; {{ end }} 首先判断当前文章是否有tag，然后根据其他widget的模板修改成current tags，使用GetTerms方法获得当前文章的tags，作为\u0026lt;a\u0026gt;标签的参数。\n注意\u0026lt;h2\u0026gt;标签中的T函数，用于在修改页面语言时批量替换文本，我们需要在对应文件中添加widget.curTags.title命名空间的值。\n添加i18n替换文本 在i18n/en.yaml和i18n/zh-cn.yaml中添加相关内容，在widget域下添加内容：\nwidget: + curTags: + title: + other: Tags of current blog 添加scss样式表 在assets/scss/partials/widgets.scss中添加curTags的样式。\n/* Current tags widget */ .curTags { .curTags-tags { display: flex; flex-wrap: wrap; gap: 10px; a { background: var(--card-background); box-shadow: var(--shadow-l1); border-radius: var(--tag-border-radius); padding: 8px 20px; color: var(--card-text-color-main); font-size: 1.4rem; transition: box-shadow 0.3s ease; \u0026amp;:hover { box-shadow: var(--shadow-l2); } } } } 自此，current tags控件的开发已经成功，在stack/config.yaml中添加配置项即可。\nparams: widgets: page: + - type: cur-tags ","date":"2025-02-12T16:33:24+08:00","image":"https://xingfend.github.io/xingfen-star.github.io/post/blogbuild2-widgets/blogbuild2_hu_e35aa4add03418f0.png","permalink":"https://xingfend.github.io/xingfen-star.github.io/post/blogbuild2-widgets/","title":"Widgets修复与开发"},{"content":"c语言高级参数解析库的实现 ","date":"2025-02-09T20:32:58+08:00","permalink":"https://xingfend.github.io/xingfen-star.github.io/post/c-args-parser/","title":"C Args Parser"},{"content":"Archive页介绍 archive页面展示了当前博文的所有类型，在此之下依据年份时序展示所有博文。\n改造计划:\n添加对以tag分类的支持\n支持在archive页展示tag模块\n修改tag\u0026ndash;tile的大小\n修改tag\u0026ndash;tile的排列方式\n为tag分类的每一个tile添加不同颜色\n修复在archive页面的category tile展示异常\n修复category详细页的文章数量异常\n添加archive页面对应配置项\n使用开发者工具检查archive页面元素 发现category分类的元素为：\n\u0026lt;h2 class=\u0026#34;section-title\u0026#34;\u0026gt;类别 - Categories\u0026lt;/h2\u0026gt; \u0026lt;div class=\u0026#34;subsection-list\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;article-list--tile\u0026#34;\u0026gt; \u0026lt;article\u0026gt; \u0026lt;/article\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 显然\u0026lt;div class=\u0026quot;article-list--tile\u0026quot;\u0026gt;的class属性命名并不合理，因为在archive首页展示的category列表的每一个tile并不是一篇article，因此应当修改为\u0026lt;div class=\u0026quot;category-list--tile\u0026quot;\u0026gt;。\n在文件themes/hugo-theme-stack/layouts/_default/archives.html中将\u0026lt;div class=\u0026quot;article-list--tile\u0026quot;\u0026gt;修改为\u0026lt;div class=\u0026quot;category-list--tile\u0026quot;\u0026gt;。\n同时将下列文件中的选择器article-list--tile修改为category-list--tile。在scss文件中建议保留原有的选择器，新增修改名称后的选择器。\nthemes/hugo-theme-stack/assets/scss/partials/article.scss themes/hugo-theme-stack/assets/scss/partials/layout/list.scss /home/fendy/Project/BlogSrc/themes/hugo-theme-stack/assets/ts/main.ts 修复category tile展示异常 本质上是没有添加对hidden文章的判断逻辑，在themes/hugo-theme-stack/layouts/_default/archives.html中添加筛选逻辑：\n\u0026lt;h2 class=\u0026#34;section-title\u0026#34;\u0026gt;类别 - {{ $cateTaxonomy.Title }}\u0026lt;/h2\u0026gt; \u0026lt;div class=\u0026#34;subsection-list\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;category-list--tile\u0026#34;\u0026gt; {{ range $cateTerms }} {{- $pages := .Pages -}} {{- $filteredPages := where $pages \u0026#34;.Params.hidden\u0026#34; \u0026#34;!=\u0026#34; true -}} {{ if $filteredPages }} {{ partial \u0026#34;article-list/tile\u0026#34; (dict \u0026#34;context\u0026#34; . \u0026#34;size\u0026#34; \u0026#34;250x150\u0026#34; \u0026#34;Type\u0026#34; \u0026#34;taxonomy\u0026#34;) }} {{ end }} {{ end }} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 添加对tag分类的支持 支持在archive页展示tag模块 在themes/hugo-theme-stack/layouts/_default/archives.html中，类别模块的下方添加如下代码：\n{{- $tagTaxonomy := $.Site.GetPage \u0026#34;taxonomyTerm\u0026#34; \u0026#34;tags\u0026#34; -}} {{- $tagTerms := $tagTaxonomy.Pages -}} {{ if $tagTerms }} \u0026lt;h2 class=\u0026#34;section-title\u0026#34;\u0026gt;标签 - {{ $tagTaxonomy.Title }}\u0026lt;/h2\u0026gt; \u0026lt;div class=\u0026#34;subsection-list\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;tag-list--tile\u0026#34;\u0026gt; {{ range $tagTerms }} {{/* 获取当前标签下的所有页面 */}} {{- $pages := .Pages -}} {{/* 过滤掉 hidden 为 true 的页面 */}} {{- $filteredPages := where $pages \u0026#34;.Params.hidden\u0026#34; \u0026#34;!=\u0026#34; true -}} {{ if $filteredPages }} {{ partial \u0026#34;article-list/tile\u0026#34; (dict \u0026#34;context\u0026#34; . \u0026#34;Type\u0026#34; \u0026#34;tag\u0026#34; \u0026#34;pages\u0026#34; $filteredPages) }} {{ end }} {{ end }} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; {{ end }} 添加tag的样式并修改tag\u0026ndash;tile的大小 在themes/hugo-theme-stack/assets/scss/partials/article.scss中添加:\n.tag-list--tile { article { border-radius: var(--card-border-radius); overflow: hidden; position: relative; height: 350px; width: 250px; box-shadow: var(--shadow-l1); transition: box-shadow 0.3s ease; background-color: var(--card-background); \u0026amp;:hover { box-shadow: var(--shadow-l2); } .article-details { border-radius: var(--card-border-radius); position: relative; height: 100%; width: 100%; display: flex; flex-direction: column; justify-content: flex-end; z-index: 2; padding: 15px; @include respond(sm) { padding: 20px; } } .article-title { font-size: 2rem; font-weight: 500; color: var(--card-text-color-main); @include respond(sm) { font-size: 2.2rem; } } } } 在themes/hugo-theme-stack/assets/scss/partials/layout/list.scss中添加:\n.tag-list--tile { display: flex; article { width: 120px; height: 30px; margin-right: 20px; flex-shrink: 0; .article-title { margin: 0; font-size: 1.8rem; } .article-details { padding-bottom: 5px; text-align: center; } } } 添加archives页面对应配置项 设计配置项 由于目前archives页面有三个板块：Categories，Tags，Dates。考虑添加如下配置项（标注出的为默认配置，不进行配置也会以下面代码块给定的配置渲染）：\nparams: archives: showCategories: true showTags: false showDates: true 修改对应源码读取配置项 修改layouts/_default/archives.html文件，将{{ if $term }}判断语句添加一个与项，同时修改变量名。最终修改后结果如下：\n{{ if and (eq (.Site.Params.archives.showCategories | default true) true) (gt (len $cateTerms) 0) }} 同理，在渲染tags和dates板块的部分使用如下语句对包裹：\n{{ if and (eq (.Site.Params.archives.showTags | default false) true) (gt (len $tagTerms) 0) }} {{ /* 渲染Tags板块 */ }} {{ end }} {{ if eq (.Site.Params.archives.showDates | default true) true }} {{ /* 渲染Dates板块*/ }} {{ end }} 修复category详细页的文章数量异常问题 在layouts/_default/list.html文件中进行如下修改：\n- \u0026lt;h3 class=\u0026#34;section-count\u0026#34;\u0026gt;{{ T \u0026#34;list.page\u0026#34; (len .Pages) }}\u0026lt;/h3\u0026gt; + {{- $filteredPages := where .Pages \u0026#34;.Params.hidden\u0026#34; \u0026#34;!=\u0026#34; true -}} + \u0026lt;h3 class=\u0026#34;section-count\u0026#34;\u0026gt;{{ T \u0026#34;list.page\u0026#34; (len $filteredPages) }}\u0026lt;/h3\u0026gt; 把.Pages的元素个数替换为筛选后的元素个数。\n","date":"2025-02-02T22:46:55+08:00","image":"https://xingfend.github.io/xingfen-star.github.io/post/blogbuild1-archive/blogbuild1_hu_538f0d4bb236f725.png","permalink":"https://xingfend.github.io/xingfen-star.github.io/post/blogbuild1-archive/","title":"Archive页改造"},{"content":" 此博客搭建过程参考的资料在\u0026quot;关于\u0026quot;页面可详细了解。本文具体步骤也可能会给出具体参考的内容。\n不能正确渲染主题 - 2025.01.28 此博客采用源码-博客页分离的结构搭建。\n源码为hugo个人博客的源码，设为github私有仓库，通过git action，在每次push之后，通过hugo -D命令云端编译生成public文件夹中的内容之后将public文件夹内的内容推送到GitHub - XingfenD/xingfen-star.github.io仓库中。\n在搭建阶段，我将themes子文件夹下的第三方主题仓库设置为该主项目的子模块，导致在上传到私有仓库后，themes文件夹中没有实际的主题文件。最终导致无法编译出所选主题的页面。\n我在github action中添加步骤Print Directory以打印路径信息，最终定位此问题并修复，完整的githu action如下。\n最终博客项目的结构为三个仓库：\nHugo源码仓库(通过gitignore忽略public, resources, themes文件夹)\n主题仓库(Hugo源码仓库的public文件夹)\nGithub Page仓库(Hugo源码仓库的public文件夹)\nname: deploy # 代码提交到main分支时触发github action on: push: branches: - main jobs: deploy: runs-on: ubuntu-22.04 steps: - name: Checkout uses: actions/checkout@v4 with: fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v3 with: hugo-version: \u0026#34;latest\u0026#34; extended: true - name: Print Directory run: tree -L 3 -d - name: Clone Theme run: git clone https://github.com/XingfenD/hugo-theme-custom.git themes - name: Git Configuration run: | git config --global core.quotePath false git config --global core.autocrlf false git config --global core.safecrlf true git config --global core.ignorecase false - name: Build Web run: hugo -D - name: Print Directory run: tree -L 3 -d - name: Deploy Web uses: peaceiris/actions-gh-pages@v4 with: personal_token: ${{ secrets.ACTION_ACCESS_TOKEN }} external_repository: XingfenD/xingfen-star.github.io publish_branch: main publish_dir: public commit_message: auto deploy 主题配置后代码块显示异常 - 2025.02.02 使用hugo-theme-stack主题后\n发现在白天模式下的代码块颜色异常，如下图所示：\n在通过修改hugo-theme-stack主题的scss文件后成功定位异常原因：\nhugo编译md文件后生成的博文html文件中的codeblock为如下结构: \u0026lt;div class=\u0026#34;highlight\u0026#34;\u0026gt; \u0026lt;pre style=\u0026#34;\u0026#34;\u0026gt; \u0026lt;code class=\u0026#34;language-markdown\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34;\u0026gt; ... \u0026lt;/code\u0026gt; \u0026lt;/pre\u0026gt; \u0026lt;/div\u0026gt; 图中所示的深色异常颜色为\u0026lt;pre\u0026gt;标签的style属性控制，因此导致全局scss文件失效。\n阅读官方文档后，在`hugo.toml`中添加配置： markup.highlight.noClasses=false 问题得以修复。\n修改配置文件以激活右侧边栏 - 2025.02.12 阅读Stack主题官方文档右侧边栏配置项可以了解如何修改配置文件以激活右边栏。\n在config.yaml文件中修改配置项[params.widgets]:\nparams: widgets: homepage: - type: search - type: categories params: limit: 10 - type: tag-cloud params: limit: 10 page: - type: toc - type: categories params: limit: 5 - type: tag-cloud params: limit: 5 配置生效后右侧边栏效果如下图:\n不能正确渲染abbr, sub等特殊html标签 - 2025.02.12 查阅在线资料修复Hugo静态生成器中忽略原始HTML的方法后，在hugo.toml中添加配置项：\nmarkup.goldmark.renderer.unsafe=true 成功渲染，效果如图。\n","date":"2025-02-02T17:21:58+08:00","image":"https://xingfend.github.io/xingfen-star.github.io/post/hugo-githubio/facebook_cover_photo_2_hu_43e45dd37002c568.png","permalink":"https://xingfend.github.io/xingfen-star.github.io/post/hugo-githubio/","title":"hugo+GithubIO自建博客踩坑实录"},{"content":"本文提供了可以在 Hugo 内容文件中使用的最基本 Markdown 语法样本，同时也展示了基本 HTML 元素是否可以通过 Hugo 主题中的 CSS 被装饰。\n标题 以下 HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; 元素代表六个级别的章节标题。\u0026lt;h1\u0026gt; 是最高级别，而 \u0026lt;h6\u0026gt; 是最低级别。\n# H1 ## H2 ### H3 #### H4 ##### H5 ###### H6 H1 H2 H3 H4 H5 H6 段落 Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\n引用块 引用块元素表示来自另一个源的内容，并且可选地带有必须在 footer 或 cite 元素内的引用，以及可选的如注释和缩写的行内更改。\n无属性的引用块 Tiam, ad mint andaepu dandae nostion secatur sequo quae. 注意 在引用块中可以使用 Markdown 语法。\n带有属性的引用块 \u0026gt; 不要通过共享内存来通信，而是通过通信来共享内存。\u0026lt;br\u0026gt; \u0026gt; — \u0026lt;cite\u0026gt;Rob Pike[^1]\u0026lt;/cite\u0026gt; [^1]: 上述引用摘自 Rob Pike 在 Gopherfest 2015 年 11 月 18 日[演讲](https://www.youtube.com/watch?v=PAAkCSZUG1c)的部分内容。 不要通过共享内存来通信，而是通过通信来共享内存。\n— Rob Pike1\n表格 表格不属于核心 Markdown 规范的一部分，但 Hugo 开箱即用地支持它们。\n名称 年龄 Bob 27 Alice 23 表格中的内联 Markdown 斜体 粗体 代码 斜体 粗体 代码 A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien 代码块 使用反引号的代码块 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;示例 HTML5 文档\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;测试\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 使用四个空格缩进的代码块 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;示例 HTML5 文档\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;测试\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;示例 HTML5 文档\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;测试\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 使用 Hugo 的内部 highlight 短代码的代码块 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;示例 HTML5 文档\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;测试\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff 代码块 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] 列表类型 有序列表 第一项 第二项 第三项 无序列表 列表项 另一个项目 再一个项目 嵌套列表 水果 苹果 橙子 香蕉 奶制品 牛奶 奶酪 其他元素——abbr, sub, sup, kbd, mark \u0026lt;abbr title=\u0026#34;图形交换格式\u0026#34;\u0026gt;GIF\u0026lt;/abbr\u0026gt; 是一种位图图像格式。 H\u0026lt;sub\u0026gt;2\u0026lt;/sub\u0026gt;O X\u0026lt;sup\u0026gt;n\u0026lt;/sup\u0026gt; + Y\u0026lt;sup\u0026gt;n\u0026lt;/sup\u0026gt; = Z\u0026lt;sup\u0026gt;n\u0026lt;/sup\u0026gt; 按下 \u0026lt;kbd\u0026gt;CTRL\u0026lt;/kbd\u0026gt; + \u0026lt;kbd\u0026gt;ALT\u0026lt;/kbd\u0026gt; + \u0026lt;kbd\u0026gt;Delete\u0026lt;/kbd\u0026gt; 结束会话。 大多数 \u0026lt;mark\u0026gt;蝾螈\u0026lt;/mark\u0026gt; 是夜行性的，并猎食昆虫、蠕虫和其他小生物。 GIF 是一种位图图像格式。\nH2O\nXn + Yn = Zn\n按下 CTRL + ALT + Delete 结束会话。\n大多数 蝾螈 是夜行性的，并猎食昆虫、蠕虫和其他小生物。\n超链接图片 上述引用摘自 Rob Pike 在 Gopherfest 2015 年 11 月 18 日演讲的部分内容。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2025-02-02T00:00:00Z","image":"https://xingfend.github.io/xingfen-star.github.io/post/markdown-syntax/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu_e95a4276bf860a84.jpg","permalink":"https://xingfend.github.io/xingfen-star.github.io/post/markdown-syntax/","title":"Markdown 语法指南"},{"content":"getopt.h简介 getopt.h 是C语言中一个用于处理命令行参数的内嵌库。可以通过以下两个函数来调用其功能：\ngetopt()\ngetopt_long()\n函数 getopt() getopt() 用于解析仅包含短选项的指令，例如 -g、-o、-f。\ngetopt() 示例程序 使用 getopt() 的参数处理框架如下：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;getopt.h\u0026gt; int main(int argc, char *argv[]) { int opt; /* parse the command line input */ while ((opt = getopt(argc, argv, \u0026#34;f:o:kh\u0026#34;)) != -1) { switch (opt) { case \u0026#39;f\u0026#39;: printf(\u0026#34;Arg -f: %s\\n\u0026#34;, optarg); break; case \u0026#39;o\u0026#39;: printf(\u0026#34;Arg -o: %s\\n\u0026#34;, optarg); break; case \u0026#39;k\u0026#39;: printf(\u0026#34;Arg -k do not need arguments:%s\\n\u0026#34;, optarg); break; case \u0026#39;h\u0026#39;: printf(\u0026#34;Arg -k do not need arguments:%s\\n\u0026#34;, optarg); break; case \u0026#39;?\u0026#39;: // An invalid option was found or a required argument is missing. if (optopt == \u0026#39;f\u0026#39; || optopt == \u0026#39;o\u0026#39;) { printf(\u0026#34;Option -%c requires an argument.\\n\u0026#34;, optopt); } else { printf(\u0026#34;Unknown option -%c.\\n\u0026#34;, optopt); } break; default: printf(\u0026#34;Unexpected situation.\\n\u0026#34;); break; } } /* extra arguments handling */ if (optind \u0026lt; argc) { printf(\u0026#34;Remaining arguments: \u0026#34;); for (; optind \u0026lt; argc; optind++) { printf(\u0026#34;%s \u0026#34;, argv[optind]); } } /* optind \u0026lt; argc */ } 编译并运行如下指令：./test_short.out -v yuanshen -f arg:f -o arg:o -k arg:k -h arg:h\n\u0026gt; ./test_short.out -v yuanshen -f arg:f -o arg:o -k arg:k -h arg:h ./test_short.out: invalid option -- \u0026#39;v\u0026#39; Invalid option: v Arg -f: arg:f Arg -o: arg:o Arg -k do not need arguments:(null) Arg -k do not need arguments:(null) Remaining arguments: yuanshen arg:k arg:h % getopt()详细说明 全局变量 全局变量 用途 optopt (int) 遇到未知选项或缺少必要参数时设置，存储导致错误的选项字符。 optarg (char*) 存储当前选项的参数值。当解析需要参数的选项（例如 -f file.txt 中的 file.txt）时，optarg 指向该字符串。 optind (int) 在解析命令行参数过程中，追踪位置，具体指示下一个要处理的参数的索引。 以下代码段会打印所有未被 getopt() 识别的参数（忽略这些参数的输入顺序）：\n/* extra arguments handling */ if (optind \u0026lt; argc) { printf(\u0026#34;Remaining arguments: \u0026#34;); for (; optind \u0026lt; argc; optind++) { printf(\u0026#34;%s \u0026#34;, argv[optind]); } } 模式字符串 模式字符串的定义是 const char *__shortopts，在示例程序中，其实例为 \u0026quot;f:o:kh\u0026quot;。\n顾名思义，模式字符串定义了 getopt() 和 getopt_long() 函数中将被识别的短选项。冒号 : 跟在短选项字符后表示该选项需要一个参数。\n以 \u0026quot;f:o:kh\u0026quot; 为例，此模式字符串接收4个选项。选项 -f 和 -o 需要输入参数，而选项 -k 和 -h 不需要。\n注意：如果 -f 后跟一个选项，该选项会被视为参数。\n函数 getopt_long() getopt_long() 用于解析既包含短选项（如 -g、-o、-f）又包含长选项（如 --version、--input）的指令。\n函数 getopt_long 识别一个结构体数组 struct option，该数组定义了长选项的信息。\nstruct option 的原型及相关介绍如下：\nstruct option { const char *name; /* 长选项的名称 */ int has_arg; /* 是否需要参数 */ int *flag; /* 如果用户提供了此选项，*flag 将被赋值为 @val */ int val; /* 将长选项与短选项绑定，或赋值给 @*flag */ }; 字段 has_arg 有两个有效值，即宏 no_argument 和 required_argument。\n如果字段 flag 未提供，则字段 val 会被视为与当前长选项绑定的短选项。\n如果提供了字段 flag，当用户提供当前长选项时，字段 val 将被赋值给 *flag。\n用实例详细说明 以下是一个使用 struct option 数组和模式字符串的实例：\n/* the corresponding pattern string */ const char *pattern = \u0026#34;suR:\u0026#34;; struct option long_options[] = { /* long option only */ /* with flag set - 1 */ { \u0026#34;onlyset1\u0026#34;, no_argument, \u0026amp;onlyset1, 1 }, /* long option only */ /* with flag set - 2 */ { \u0026#34;onlyset2\u0026#34;, no_argument, \u0026amp;onlyset1, 2 }, /* long option only */ /* with flag set - 3 */ { \u0026#34;onlyset3\u0026#34;, no_argument, \u0026amp;onlyset2, 3 }, /* long option only ( bind failed ) */ /* with flag set, with val bind */ { \u0026#34;setbind\u0026#34;, no_argument, \u0026amp;setbind_flag, \u0026#39;s\u0026#39; }, /* short and long option */ /* without flag set, with val bind */ { \u0026#34;unsetbind\u0026#34;, no_argument, NULL, \u0026#39;u\u0026#39; }, /* short and long option */ /* require argument */ { \u0026#34;RequireArg\u0026#34;, required_argument, NULL, \u0026#39;R\u0026#39; }, }; 考虑到短选项和长选项，当提到某个功能的option时，可能会有以下三种情况：\n仅有短选项 仅有长选项 同时具有短选项和长选项 结合模式字符串和 struct option 数组，程序接收的选项如下：\n短选项 长选项 \u0026ndash;onlyset1 \u0026ndash;onlyset2 \u0026ndash;onlyset3 \u0026ndash;setbind -s -u \u0026ndash;unsetbind -R \u0026ndash;RequireArg 选项 -s 和 --setbind 并未绑定在一起，因为在与 \u0026quot;setbind\u0026quot; 对应的结构体元素中设置了字段 flag。\n参数需求冲突 当短选项和长选项中都定义了参数需求时，可能会发生冲突。\n我们通过一个实例进行说明：\n/* the corresponding pattern string */ const char *pattern = \u0026#34;c:d\u0026#34;; struct option long_options = { /* short and long option */ /* conflict argument require - 1 */ { \u0026#34;Conflict1\u0026#34;, no_argument, NULL, \u0026#39;c\u0026#39; }, /* short and long option */ /* conflict argument require - 2 */ { \u0026#34;Conflict2\u0026#34;, required_argument, NULL, \u0026#39;d\u0026#39;}, /* end of the array ( all zero ) */ { 0, 0, 0, 0 } }; 我们可以看到，上述程序将一个需要参数的短选项 -c 与一个不需要参数的长选项 --Conflict1 绑定在一起。\n同时，它还将一个不需要参数的短选项 -d 与一个需要参数的长选项 --Conflict2 绑定在一起。\n该程序运行正常，但关于参数的配置也会生效。\n当用户提供 -c 或 --Conflict1 时，程序会进入同一个分支，但 --Conflict1 不会读取后续的参数，而 -c 会读取。\n当用户提供 -d 或 --Conflict2 时，结果则相反。\ngetopt_long() 示例程序 以下是使用 getopt_long() 的参数处理框架：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;getopt.h\u0026gt; /* test instructions: ./test_long.out --onlyset1 --onlyset2 --onlyset3 ./test_long.out -s --setbind ./test_long.out --unsetbind --RequireArg arg:RequireArg ./test_long.out -u -R arg:R ./test_long.out -c arg:c -d arg:d ./test_long.out --Conflict1 arg:Conflict1 --Conflict2 arg:Conflict2 ./test_long.out -c arg:c --Conflict1 arg:Conflict1 ./test_long.out --Conflict1 arg:Conflict1 -c arg:c */ int main(int argc, char *argv[]) { int opt; int onlyset1 = 0; int onlyset2 = 0; int setbind_flag = 0; struct option long_options[] = { /* long option only */ /* with flag set - 1 */ { \u0026#34;onlyset1\u0026#34;, no_argument, \u0026amp;onlyset1, 1 }, /* long option only */ /* with flag set - 2 */ { \u0026#34;onlyset2\u0026#34;, no_argument, \u0026amp;onlyset1, 2 }, /* long option only */ /* with flag set - 3 */ { \u0026#34;onlyset3\u0026#34;, no_argument, \u0026amp;onlyset2, 3 }, /* long option only ( bind failed ) */ /* with flag set, with val bound */ { \u0026#34;setbind\u0026#34;, no_argument, \u0026amp;setbind_flag, \u0026#39;s\u0026#39; }, /* short and long option */ /* without flag set, with val bound */ { \u0026#34;unsetbind\u0026#34;, no_argument, NULL, \u0026#39;u\u0026#39; }, /* short and long option */ /* require argument */ { \u0026#34;RequireArg\u0026#34;, required_argument, NULL, \u0026#39;R\u0026#39; }, /* short and long option */ /* conflict argument require - 1 */ { \u0026#34;Conflict1\u0026#34;, no_argument, NULL, \u0026#39;c\u0026#39; }, /* short and long option */ /* conflict argument require - 2 */ { \u0026#34;Conflict2\u0026#34;, required_argument, NULL, \u0026#39;d\u0026#39;}, /* end of the array ( all zero ) */ { 0, 0, 0, 0 } }; int long_index = 0; while ((opt = getopt_long(argc, argv, \u0026#34;suR:c:d\u0026#34;, long_options, \u0026amp;long_index)) != -1) { switch (opt) { case 0: /* provide long option with flag set */ printf(\u0026#34;long option with flag set recognized!\\n\u0026#34;); printf(\u0026#34;long option name is %s\\n\u0026#34;, long_options[long_index].name); if (long_options[long_index].flag != NULL) { printf(\u0026#34;the flag value is %d\\n\u0026#34;, *(long_options[long_index].flag)); } break; case \u0026#39;s\u0026#39;: /* provide option -s instead of --setbind */ printf(\u0026#34;long option (short option only), with flag set, with val bound.\\n\u0026#34;); printf(\u0026#34;setbind_flag == %d\\n\u0026#34;, setbind_flag); break; case \u0026#39;u\u0026#39;: /* provide option -u and --unsetbind */ printf(\u0026#34;long option, without flag set, with val bound.\\n\u0026#34;); break; case \u0026#39;R\u0026#39;: /* provide option -R and --RequireArg */ printf(\u0026#34;long option require argument.\\n\u0026#34;); printf(\u0026#34;the argument: %s\\n\u0026#34;, optarg); break; case \u0026#39;c\u0026#39;: /* -c require an argument while --Conflict1 not */ printf(\u0026#34;conflict argument require - 1\\n\u0026#34;); printf(\u0026#34;the argument: %s\\n\u0026#34;, optarg); break; case \u0026#39;d\u0026#39;: /* --Conflict2 require an argument while -d not */ printf(\u0026#34;conflict argument require - 2\\n\u0026#34;); printf(\u0026#34;the argument: %s\\n\u0026#34;, optarg); break; case \u0026#39;?\u0026#39;: /* Unrecognized option or missing argument */ printf(\u0026#34;Unknown option or missing argument.\\n\u0026#34;); break; } printf(\u0026#34;\\n\u0026#34;); } /* Process remaining non-option arguments */ for (int index = optind; index \u0026lt; argc; index++) printf(\u0026#34;Non-option argument %s\\n\u0026#34;, argv[index]); return 0; } 运行测试指令并分析测试结果 编译运行时的测试指令如下：\n./test_long.out --onlyset1 --onlyset2 --onlyset3 ./test_long.out -s --setbind ./test_long.out --unsetbind --RequireArg arg:RequireArg ./test_long.out -u -R arg:R ./test_long.out -c arg:c -d arg:d ./test_long.out --Conflict1 arg:Conflict1 --Conflict2 arg:Conflict2 ./test_long.out -c arg:c --Conflict1 arg:Conflict1 ./test_long.out --Conflict1 arg:Conflict1 -c arg:c 结果如下：\n\u0026gt; ./test_long.out --onlyset1 --onlyset2 --onlyset3 long option with flag set recognized! long option name is onlyset1 the flag value is 1 long option with flag set recognized! long option name is onlyset2 the flag value is 2 long option with flag set recognized! long option name is onlyset3 the flag value is 3 指令 ./test_long.out --onlyset1 --onlyset2 --onlyset3 展示了 getopt_long() 的基本功能。\n它改变了 flag 地址中的值。\n\u0026gt; ./test_long.out -s --setbind long option (short option only), with flag set, with val bound. setbind_flag == 0 long option with flag set recognized! long option name is setbind the flag value is 115 指令 ./test_long.out -s --setbind 展示了绑定失败（当 flag 字段被设置时）。\n--setbind 和 -s 会进入不同的分支。\n\u0026gt; ./test_long.out --unsetbind --RequireArg arg:RequireArg long option, without flag set, with val bound. long option require argument. the argument: arg:RequireArg \u0026gt; ./test_long.out -u -R arg:R long option, without flag set, with val bound. long option require argument. the argument: arg:R 这对比展示了绑定成功的结果（当 flag 字段未设置时）。\n--unsetbind 和 -u 被绑定在一起，进入相同的分支。\n--RequireArg 和 -R 也是一样。\n\u0026gt; ./test_long.out -c arg:c -d arg:d conflict argument require - 1 the argument: arg:c conflict argument require - 2 the argument: (null) Non-option argument arg:d \u0026gt; ./test_long.out --Conflict1 arg:Conflict1 --Conflict2 arg:Conflict2 conflict argument require - 1 the argument: (null) conflict argument require - 2 the argument: arg:Conflict2 Non-option argument arg:Conflict1 这对比展示了参数要求的冲突。\n-c 和 --Conflict1 被绑定在一起，但 -c 需要一个参数。\n-d 和 --Conflict2 被绑定在一起，但 --Conflict2 需要一个参数。\n结果显示，绑定在一起的选项会进入相同的分支。\n但是，是否读取或忽略参数取决于用户提供的选项是否需要参数。\n\u0026gt; ./test_long.out -c arg:c --Conflict1 arg:Conflict1 conflict argument require - 1 the argument: arg:c conflict argument require - 1 the argument: (null) Non-option argument arg:Conflict1 \u0026gt; ./test_long.out --Conflict1 arg:Conflict1 -c arg:c conflict argument require - 1 the argument: (null) conflict argument require - 1 the argument: arg:c Non-option argument arg:Conflict1 冲突选项的另一个对比结果。\n","date":"2025-01-22T13:29:03+08:00","permalink":"https://xingfend.github.io/xingfen-star.github.io/post/c-getopt_h-analysis/","title":"c语言getopt.h库解析"}]